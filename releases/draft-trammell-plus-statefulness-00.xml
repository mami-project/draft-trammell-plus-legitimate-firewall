<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-trammell-plus-statefulness-00" category="info">

  <front>
    <title abbrev="PLUS Statefulness">Transport-Independent Path Layer State Management</title>

    <author initials="M." surname="Kuehlewind" fullname="Mirja Kuehlewind">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Gloriastrasse 35</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <email>mirja.kuehlewind@tik.ee.ethz.ch</email>
      </address>
    </author>
    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Gloriastrasse 35</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <email>ietf@trammell.ch</email>
      </address>
    </author>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization></organization>
      <address>
        <email>hildjj@cursive.net</email>
      </address>
    </author>

    <date year="2016" month="October" day="19"/>

    
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document describes a simple state machine for stateful network devices on
a path between two endpoints to associate state with traffic traversing them
on a per-flow basis, as well as abstract signaling mechanisms for driving the
state machine. This state machine is intended to replace the de-facto use of
the TCP state machine or incomplete forms thereof by stateful network devices
in a transport-independent way, while still allowing for fast state timeout
of non-established or undesirable flows.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The boundary between the network and transport layers was originally defined
to be that between information used (and potentially modified) hop-by-hop, 
and that used end-to-end. End-to-end information in the transport layer
is associated with state at the endpoints, but processing of network-layer
information was assumed to be stateless.</t>

<t>The widespread deployment of stateful middleboxes in the Internet, such as
network address and port translators (NAPT), firewalls that model the TCP
state machine to distinguish packets belonging from desirable flows from
backscatter and random attack traffic, and devices which keep per-flow state
for reporting and monitoring purposes (e.g. IPFIX <xref target="RFC7011"/> Metering
Processes), has broken this assumption, and made it more difficult to deploy
non-TCP transport protocols in the Internet.</t>

<t>The deployment of new transport protocols encapsulated in UDP with encrypted
transport headers (such as QUIC <xref target="I-D.hamilton-quic-transport-protocol"/>) 
will present a challenge to the operation of these devices, and their ubquity
likewise threatens to impair the deployability of these protocols. There are
two main causes for this problem: first, stateful devices often use an
internal model of the TCP state machine to determine when TCP flows start and
end, allowing them to manage state for these flows; for UDP flows, they must
rely on timeouts. These timeouts are generally short relative to those for TCP
<xref target="IMC-GATEWAYS"/>, requiring UDP- encapsulated transports either to generate
unproductive keepalive traffic for long-lived sessions, or to tolerate
connectivity problems and the necessity of reconnection due to loss of on-path
state.</t>

<t>This document presents a solution to this problem by defining a state machine
that is transport independent to be implemented at per-flow state-keeping
middleboxes as a replacement for incomplete TCP state modeling. Middleboxes
implementing this state machine using signals from a common UDP encapsulation
layer can have equivalent necessary state information to that provided by TCP,
reducing the friction between middleboxes and these new transport protocols.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In this document, the term “flow” is defined to be compatible with the
definition given in <xref target="RFC7011"/>: A flow is defined as a set of packets passing
a device on the network during a certain time interval. All packets belonging
to a particular Flow have a set of common properties. Each property is defined
as the result of applying a function to the values of:</t>

<t><list style="numbers">
  <t>one or more network layer header fields (e.g., destination IP
address) or transport layer header fields (e.g., destination port
number) that the device has access to;</t>
  <t>one or more characteristics of the packet itself (e.g., number
of MPLS labels, etc.);</t>
  <t>one or more of the fields derived from packet treatment at the device
(e.g., next-hop IP address, the output interface, etc.).</t>
</list></t>

<t>A packet is defined as belonging to a flow if it completely satisfies all the
defined properties of the flow.</t>

<t>A bidirectional flow or biflow is defined as compatible with <xref target="RFC5103"/>, by
joining the “forward direction” flow with the “reverse direction” flow,
derived by reversing the direction of directional fields (ports and IP
addresses). Biflows are only relevant at devices positioned so as to see all
the packets in both directions of the biflow, generally on the endpoint side
of the service demarcation point for either endpoint as defined in the
reference path given in <xref target="RFC7398"/>.</t>

</section>
<section anchor="state-machine" title="State Machine">

<t>The transport-independent state machine for on-path devices is shown in 
<xref target="fig-states"/>. It relies on four states, three configurable timeouts, and a set of
signals defined in <xref target="abstract-signaling-mechanisms"/>. The states are defined
as follows:</t>

<t><list style="symbols">
  <t>zero: there is no state for a given flow at the device</t>
  <t>uniflow: a packet has been seen in one direction; state will be kept at the
device until it is explicitly cancelled or until timeout t1 elapses without
a packet.</t>
  <t>biflow: a packet has been seen in one direction and an indication that that 
the receiving endpoint wishes to continue the association has been seen in 
the opposite direction; state will be kept at the device until it is 
explicitly canceled or until timeout t2 elapses without a packet.</t>
  <t>closing: an established biflow is shutting down due to an explicit close
indication; state will be kept at the device until timeout t3 elapses.</t>
</list></t>

<t>The three timeouts are defined as follows:</t>

<t><list style="symbols">
  <t>t1 is the unidirectional idle timeout. It can be considered equivalent to
the idle timeout for transport protocols where the device has no information
about session start and end (e.g. most UDP protocols).</t>
  <t>t2 is the bidirectional idle timeout. It can be considered equivalent to the 
timeout for transport protocols where the device has information about session 
start and end (e.g. TCP).</t>
  <t>t3 is the closing timeout: how long the device will account additional packets 
to a flow after observing a stop signal, and is generally applied to ensuring
a reordered stop signal doesn’t create a new flow.</t>
</list></t>

<t>Selection of timeouts is a configuration and implementation detail, but
generally t3 &lt;= t1 &lt; t2.</t>

<figure title="Transport-Independent State Machine for Stateful On-Path Devices" anchor="fig-states"><artwork><![CDATA[
   _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  '                                         ' 
  '    +----+   p(s->d)   +-----+           '  
  '   /      \---------->/       \----+     '  UNIFLOW
  '  (  zero  )         ( uniflow ) p(s->d) '  ONLY 
  '   \      /<----------\       /<---+     '  STATES
  '    +----+      t1     +-----+           '
  '_ _ _ ^_^ _ _ _ _ _ _ _ _ | _ _ _ _ _ _ _'
      t3 |  \                | association
         |   \__________     v 
       +-----+     t2   \  +----+
      /       \          \/      \----+    
     ( closing )<--------( biflow ) p(s<->d)
      \       /   stop    \      /<---+    
       +-----+             +----+
    
]]></artwork></figure>

<section anchor="uniflow-states" title="Uniflow States">

<t>Every packet received by a device keeping per-flow state must associate that
packet with a flow (see <xref target="flow-identification"/>). When a device receives a
packet associated with a flow it has not state forward, and it is configured
to forward the packet instead of dropping it, it moves that flow from the zero
state into the uniflow state and starts a timer t1. It resets this timer for
any additional packet it forwards in the same direction as long as the flow
remains in the uniflow state. When timer t1 expires on a flow in the uniflow
state, the device drops state for the flow and performs any processing
associated with doing so: tearing down NAT bindings, closing associated
firewall pinholes, exporting flow information, and so on. The device may also
drop state on a stop signal, if observed.</t>

<t>Some devices will only see one side of a communication, e.g. if they are
placed in a portion of a network with asymmetric routing. These devices use
only the zero and uniflow states (as marked in <xref target="fig-states"/>.) In addition,
true uniflows – protocols which are solely unidirectional (e.g. some
applications over UDP) – will also use only the uniflow-only states. In
either case, current devices generally don’t associate much state with
observed uniflows flows, and timeout is generally sufficient to expire this
state.</t>

</section>
<section anchor="biflow-states" title="Biflow States">

<t>A uniflow transitions to the biflow state when the device observes an
association signal. An association signal consists of a packet sent in the
opposite direction from the uniflow packet(s), with certain properties as
defined in <xref target="association-signaling"/>. After transitioning to the biflow
state, the device starts a timer t2. It resets this timer for any packet it
forwards in either direction. The biflow state represents a fully established
bidirectional communication. When timer t2 expires, the device assumes that
the flow has shut down without signaling as such, and drops state for the
flow, performing any associated processing. When a stop signal is observed in
either direction, the flow transitions to the closing state.</t>

<t>When a flow enters the closing state, it starts a timer t3. While the stop
signal should be the last packet on a flow, the t3 timer ensures that
reordered packets after the stop signal will be accounted to the flow. When
this timer expires, the device drops state for the flow, performing any
associated processing.</t>

</section>
<section anchor="additional-states-and-actions" title="Additional States and Actions">

<t>This document is concerned only with states and transitions common to
transport- and function- independent state maintenance. Devices may augment
the transitions in this state diagram depending on their function. For
example, a firewall that decides based on some information beyond the signals
used by this state machine to shut down a flow may transition it directly to a
blacklist state on shutdown. Or, a firewall may fail to forward additional
packets in the uniflow state until an association signal is observed.</t>

</section>
</section>
<section anchor="abstract-signaling-mechanisms" title="Abstract Signaling Mechanisms">

<t>The state machine in <xref target="state-machine"/> requires three signals: a packet (the
first packet observed in a flow in the zero state), an association signal (allowing
a device to verify that an endpoint wishes a bidirectional communication to be
established or to continue), and a stop signal (noting that an endpoint wishes
to stop a bidirectional communication). Additional related signals may also be
useful, depending on the function a device provides. There are a few different
ways to implement these signals; here, we explore the properties of some
potential implementations.</t>

<t>We assume the following general requirements for these signals; parallel to
those given in <xref target="draft-trammell-plus-abstract-mech"/>:</t>

<t><list style="symbols">
  <t>At least the endpoints can verify the integrity of the signals exposed, and
shut down a transport association when that verification fails, in order to
reduce the incentive for on-path devices to attempt to spoof these signals.</t>
  <t>Endpoints and devices on path can probabilistically verify that a originator
of a signal is on-path.</t>
</list></t>

<section anchor="flow-identification" title="Flow Identification">

<t>In order to keep per-flow state, each device using this state machine must
have a function it can apply to each packet to be able to extract common
properties to identify the flow it is associated with. In general, the set of
properties used for flow identification on presently deployed devices includes
the source and destination IP address, the source and destination transport
layer port number, the transport protocol number. The differentiated services
field <xref target="RFC2474"/> may also be included in the set of properties defining a
flow, since it may indicate different forwarding treatment.</t>

<t>However, other protocols may use additional bits in their own headers for flow
identification. In any case, a protocol implementing signaling for this state
machine must specify the function used for flow identification.</t>

</section>
<section anchor="association-signaling" title="Association Signaling">

<t>An association signal indicates that endpoint that received the first packet seen
by the device is interested in continuing conversation with the sending
endpoint. This signal is roughly an in-band analogue to consent
signaling in ICE <xref target="RFC7675"/> that is carried to every device along the path.</t>

<t>Transport-independent, path-verifiable association signaling can be implemented
using a association token generated by one endpoint, present on each packet
sent in the flow by that endpoint, and a response token, derived from the
association token using a well-known, defined function, present on each packet
sent in the flow by the opposite endpoint. We can assume a transport
association has an initiator and a responder; under this assumption, the
association token is chosen by the initiator, and the response token generated
by the responder.</t>

<t>Any packet sent by the responder with a valid response token, and without a
stop signal (see <xref target="stop-signaling"/>), can then be taken to be a association signal
to continue a bidirectional communication. Note that, since it relies on a
widely-known function, this mechanism does allow on-path devices to forge
association signaling in a way that downstream on-path devices cannot detect.
However, in the presence of end-to-end signal integrity verification, this
forgery will be detected by the endpoint, which MUST terminate the association
on a forged association signal; the flow at the duped on-path device will
transition from biflow to closing within a single packet. This reduces any
attack against the association signaling mechanism to the disruption of a
connection, which on-path devices can do in any case by simply refusing to
forward packets.</t>

<t>Association tokens MUST be chosen by initiators to be hard to guess;
otherwise, off-path devices can spoof association and response signals.
Cryptographic random number generators suffice here. In choosing the number of
bits for an association token, there is a tradeoff between per-packet overhead
and state overhead at on-path devices, and assurance that an association token
is hard to guess. This tradeoff must be evaluated at protocol design time.</t>

<t>There are a few considerations in choosing a function (or functions) to
generate the response token from the association token, and to verify a
response token given an association token. The simplest such function is the
identity function: the response token is simply the association token. Simple
two-way functions (e.g. one’s complement of the association token) provide
additional assurance of implementation of the protocol, and cannot be
accidentally triggered by simple reflection of unknown bits in a packet. One-
way functions (e.g. truncated SHA-2 hash of the association token)
additionally allow on-path recognition of initiator and responder from the
middle of a flow.</t>

<t>In any case, a concrete implementation of
association signaling must choose a single function, or mechanism for
unambiguously choosing one, at both endpoints as well as along the path.</t>

</section>
<section anchor="stop-signaling" title="Stop Signaling">

<t>A stop signal is directly carried or otherwise encoded in the protocol
header to indicate that a flow is ending, whether normally or abnormally, and
that state associated with the flow should be torn down. Upon decoding a stop
signal, a device on path should move the flow from uniflow state to null, or
from biflow state to closing.</t>

<t>Transports should send a stop signal only on the last packet sent in a
bidirectional flow. The closing timeout t3 is intended to ensure that any
packets reordered in delivery are accounted to the flow before state for it is
dropped.</t>

<t>We assume the encoding of a stop signal into a packet header, as with all
other signals, is integrity protected end-to-end. Stop signals, as association
signals, be forged by one on-path device to dupe other devices into moving
flows into the closing state. However, state will be re-established by the
continuing flow (and resulting association signals) after the closing timeout, and
an endpoint receiving a spoofed stop signal could enter a fast 
re-establishment phase of the upper layer transport protocol to minimize
disruption, further reducing the incentive to attackers to spoof stop signals.</t>

<!--
## Header-Only Forwarding

[EDITOR'S NOTE: probably cut this, since it is extremely expensive to implement on path; potentially move it to the plus protocol document as an optional feature, since it makes some assumptions about PLUS we don't here: A network device in "no state" might only forward the unencrypted/header parts of a packet to transition to "biflow" state without forwarding unknow data. A PLUS receiver MUST reply with a (PLUS-only) packet (within a given time frame). On receiption of this PLUS-only packet, the network device tranits in "biflow" state and SHOULD resend the whole packet including the encrypted data while dropping a PLUS-only packet. If the network device was not able to store the encrypted data, it forwards the PLUS-only packet to the original sending endpoint which then can be used as a fast trigger that the original encrypted data was not received by the intented receiving endpoint.]
-->

</section>
<section anchor="timeout-exposure" title="Timeout Exposure">

<t>Since one of the goals of these mechanisms is to reduce the amount of non-
productive keepalive traffic required for UDP-encapsulated transport
protocols, they MAY be deployed together with a path-to-receiver signal with
feedback as defined in <xref target="draft-trammell-plus-abstract-mech"/> asking for timeouts
t1, t2, and t3 for a given flow.</t>

</section>
</section>
<section anchor="signal-mappings-for-transport-protocols" title="Signal mappings for transport protocols">

<t>We now show how this state machine can be driven by signals available in TCP and QUIC.</t>

<section anchor="signal-mapping-for-tcp" title="Signal mapping for TCP">

<t>A mapping of TCP flags to transitions in to the state machine in 
<xref target="state-machine"/> shows how devices currently using a model of the TCP state machine
can be converted to use this state machine.</t>

<t>Simply speaking, an ACK flag <xref target="RFC0793"/> in the absence of the FIN or RST
flags, and an in-window acknowledgment number, is synonymous with the
association signal, while the RST or final FIN flags are stop signals. For a
typical TCP flow:</t>

<t><list style="numbers">
  <t>The initial SYN places the flow into uniflow state,</t>
  <t>The SYN-ACK sent in reply acts as a association signal and places the flow into biflow state,</t>
  <t>Any RST moves the flow into closing state, or</t>
  <t>The final FIN-ACK (not the first half-close FIN) moves the flow into closing state.</t>
</list></t>

<t>Note that since any valid ACK acts as an association signal, this mapping
allows flows to transition to the biflow state even if the initial SYN-ACK is
not observed. However, generating a stop signal from FIN does require
additional TCP state modeling to prevent moving into the closing state on a
half-close.</t>

<t>Note that the association and stop signals derived from the TCP header are not
integrity protected, and an association signal based on in-window ACK is not
particularly resistant to off-path attacks; the state machine is therefore
more susceptible to manipulation when used with vanilla TCP as when with a
transport protocol providing full integrity protection for its headers 
end-to-end.</t>

</section>
<section anchor="signal-mapping-for-quic" title="Signal mapping for QUIC">

<t>QUIC <xref target="I-D.hamilton-quic-transport-protocol"/> as presently defined lacks only
a stop signal to be able to drive this state machine. QUIC’s 64-bit connection
ID suffices as an association and response token as in 
<xref target="association-signaling"/>; the response token function is identity. QUIC’s cryptographic
protocol, to be based on TLS <xref target="I-D.thomson-quic-tls"/>, will provide the
necessary integrity protection to drive the state machine.</t>

<t>Any number of designs could be chosen to add a stop signal compatible with the
definition in <xref target="stop-signaling"/> to QUIC. One is particularly promising,
however. We note that the Public Reset facility described in  section 8 of
<xref target="I-D.hamilton-quic-transport-protocol"/> very nearly meets the criteria; it
would need to be expanded to expose normal termination as well as abnormal
termination, and to provide for endpoint detection of inauthentic termination
signals.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no actions for IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This document defines a state machine for transport-independent state
management on middleboxes, using in-band signaling, to replace the commonly-
implemented current practice of incomplete TCP state modeling on these
devices. It defines new signals for state management. While these signals can
be spoofed by any device on path that observes traffic in both directions, we
presume the presence of end-to-end integrity protection of these signals
provided by the upper-layer transport driving them. This allows such spoofing
to be detected and countered by endpoints, reducing the threat from on-path
devices to connection disruption, which such devices are trivially placed to
perform in any case.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>Thanks to Christian Huitema for discussions leading to this document.</t>

<t>This work is partially supported by the European Commission under Horizon 2020
grant agreement no. 688421 Measurement and Architecture for a Middleboxed
Internet (MAMI), and by the Swiss State Secretariat for Education, Research,
and Innovation under contract no. 15.0268. This support does not imply
endorsement.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC5103' target='http://www.rfc-editor.org/info/rfc5103'>
<front>
<title>Bidirectional Flow Export Using IP Flow Information Export (IPFIX)</title>
<author initials='B.' surname='Trammell' fullname='B. Trammell'><organization /></author>
<author initials='E.' surname='Boschi' fullname='E. Boschi'><organization /></author>
<date year='2008' month='January' />
<abstract><t>This document describes an efficient method for exporting bidirectional flow (Biflow) information using the IP Flow Information Export (IPFIX) protocol, representing each Biflow using a single Flow Record.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5103'/>
<seriesInfo name='DOI' value='10.17487/RFC5103'/>
</reference>



<reference  anchor='RFC7011' target='http://www.rfc-editor.org/info/rfc7011'>
<front>
<title>Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information</title>
<author initials='B.' surname='Claise' fullname='B. Claise' role='editor'><organization /></author>
<author initials='B.' surname='Trammell' fullname='B. Trammell' role='editor'><organization /></author>
<author initials='P.' surname='Aitken' fullname='P. Aitken'><organization /></author>
<date year='2013' month='September' />
<abstract><t>This document specifies the IP Flow Information Export (IPFIX) protocol, which serves as a means for transmitting Traffic Flow information over the network.  In order to transmit Traffic Flow information from an Exporting Process to a Collecting Process, a common representation of flow data and a standard means of communicating them are required.  This document describes how the IPFIX Data and Template Records are carried over a number of transport protocols from an IPFIX Exporting Process to an IPFIX Collecting Process.  This document obsoletes RFC 5101.</t></abstract>
</front>
<seriesInfo name='STD' value='77'/>
<seriesInfo name='RFC' value='7011'/>
<seriesInfo name='DOI' value='10.17487/RFC7011'/>
</reference>



<reference  anchor='RFC7398' target='http://www.rfc-editor.org/info/rfc7398'>
<front>
<title>A Reference Path and Measurement Points for Large-Scale Measurement of Broadband Performance</title>
<author initials='M.' surname='Bagnulo' fullname='M. Bagnulo'><organization /></author>
<author initials='T.' surname='Burbridge' fullname='T. Burbridge'><organization /></author>
<author initials='S.' surname='Crawford' fullname='S. Crawford'><organization /></author>
<author initials='P.' surname='Eardley' fullname='P. Eardley'><organization /></author>
<author initials='A.' surname='Morton' fullname='A. Morton'><organization /></author>
<date year='2015' month='February' />
<abstract><t>This document defines a reference path for Large-scale Measurement of Broadband Access Performance (LMAP) and measurement points for commonly used performance metrics.  Other similar measurement projects may also be able to use the extensions described here for measurement point location.  The purpose is to create an efficient way to describe the location of the measurement point(s) used to conduct a particular measurement.</t></abstract>
</front>
<seriesInfo name='RFC' value='7398'/>
<seriesInfo name='DOI' value='10.17487/RFC7398'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC0793' target='http://www.rfc-editor.org/info/rfc793'>
<front>
<title>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1981' month='September' />
</front>
<seriesInfo name='STD' value='7'/>
<seriesInfo name='RFC' value='793'/>
<seriesInfo name='DOI' value='10.17487/RFC0793'/>
</reference>



<reference  anchor='RFC2474' target='http://www.rfc-editor.org/info/rfc2474'>
<front>
<title>Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</title>
<author initials='K.' surname='Nichols' fullname='K. Nichols'><organization /></author>
<author initials='S.' surname='Blake' fullname='S. Blake'><organization /></author>
<author initials='F.' surname='Baker' fullname='F. Baker'><organization /></author>
<author initials='D.' surname='Black' fullname='D. Black'><organization /></author>
<date year='1998' month='December' />
<abstract><t>This document defines the IP header field, called the DS (for differentiated services) field.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='2474'/>
<seriesInfo name='DOI' value='10.17487/RFC2474'/>
</reference>



<reference  anchor='RFC7675' target='http://www.rfc-editor.org/info/rfc7675'>
<front>
<title>Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness</title>
<author initials='M.' surname='Perumal' fullname='M. Perumal'><organization /></author>
<author initials='D.' surname='Wing' fullname='D. Wing'><organization /></author>
<author initials='R.' surname='Ravindranath' fullname='R. Ravindranath'><organization /></author>
<author initials='T.' surname='Reddy' fullname='T. Reddy'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson'><organization /></author>
<date year='2015' month='October' />
<abstract><t>To prevent WebRTC applications, such as browsers, from launching attacks by sending traffic to unwilling victims, periodic consent to send needs to be obtained from remote endpoints.</t><t>This document describes a consent mechanism using a new Session Traversal Utilities for NAT (STUN) usage.</t></abstract>
</front>
<seriesInfo name='RFC' value='7675'/>
<seriesInfo name='DOI' value='10.17487/RFC7675'/>
</reference>



<reference anchor='I-D.hamilton-quic-transport-protocol'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>

<author initials='R' surname='Hamilton' fullname='Ryan Hamilton'>
    <organization />
</author>

<author initials='J' surname='Iyengar' fullname='Janardhan Iyengar'>
    <organization />
</author>

<author initials='I' surname='Swett' fullname='Ian Swett'>
    <organization />
</author>

<author initials='A' surname='Wilk' fullname='Alyssa Wilk'>
    <organization />
</author>

<date month='July' day='8' year='2016' />

<abstract><t>QUIC (Quick UDP-based Internet Connection) is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience, and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the basis of QUIC is intended to address compatibility issues with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing third parties from from changing them.  QUIC encrypts most of its headers, thereby limiting protocol evolution to QUIC endpoints only.  Therefore, middleboxes, in large part, are not required to be updated as new protocol versions are deployed.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection- level flow control, and data reliability.  Accompanying documents describe QUIC's loss recovery and congestion control, and the use of TLS1.3 for key negotiation.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-hamilton-quic-transport-protocol-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hamilton-quic-transport-protocol-00.txt' />
</reference>



<reference anchor='I-D.thomson-quic-tls'>
<front>
<title>Porting QUIC to Transport Layer Security (TLS)</title>

<author initials='M' surname='Thomson' fullname='Martin Thomson'>
    <organization />
</author>

<author initials='R' surname='Hamilton' fullname='Ryan Hamilton'>
    <organization />
</author>

<date month='March' day='21' year='2016' />

<abstract><t>The QUIC experiment defines a custom security protocol.  This was necessary to gain handshake latency improvements.  This document describes how that security protocol might be replaced with TLS.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-thomson-quic-tls-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-thomson-quic-tls-00.txt' />
</reference>


<reference anchor="draft-trammell-plus-abstract-mech" >
  <front>
    <title>Abstract Mechanisms for a Cooperative Path Layer under Endpoint Control</title>
    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization>ETH Zurich</organization>
    </author>
    <date year="2016" month="September" day="28"/>
  </front>
</reference>
<reference anchor="IMC-GATEWAYS" >
  <front>
    <title>An experimental study of home gateway characteristics (Proc. ACM IMC 2010)</title>
    <author initials="S." surname="Hatonen">
      <organization></organization>
    </author>
    <author initials="A." surname="Nyrhinen">
      <organization></organization>
    </author>
    <author initials="L." surname="Eggert">
      <organization></organization>
    </author>
    <author initials="S." surname="Strowes">
      <organization></organization>
    </author>
    <author initials="P." surname="Sarolahti">
      <organization></organization>
    </author>
    <author initials="M." surname="Kojo">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>


    </references>



  </back>
</rfc>

