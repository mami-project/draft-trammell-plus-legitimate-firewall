<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-trammell-plus-statefulness-01" category="info">

  <front>
    <title abbrev="PLUS Statefulness">Transport-Independent Path Layer State Management</title>

    <author initials="M." surname="Kuehlewind" fullname="Mirja Kuehlewind">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Gloriastrasse 35</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <email>mirja.kuehlewind@tik.ee.ethz.ch</email>
      </address>
    </author>
    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization>ETH Zurich</organization>
      <address>
        <postal>
          <street>Gloriastrasse 35</street>
          <city>8092 Zurich</city>
          <country>Switzerland</country>
        </postal>
        <email>ietf@trammell.ch</email>
      </address>
    </author>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization></organization>
      <address>
        <email>hildjj@cursive.net</email>
      </address>
    </author>

    <date year="2016" month="November" day="30"/>

    
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document describes a simple state machine for stateful network devices on
a path between two endpoints to associate state with traffic traversing them
on a per-flow basis, as well as abstract signaling mechanisms for driving the
state machine. This state machine is intended to replace the de-facto use of
the TCP state machine or incomplete forms thereof by stateful network devices
in a transport-independent way, while still allowing for fast state timeout
of non-established or undesirable flows.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The boundary between the network and transport layers was originally defined
to be that between information used (and potentially modified) hop-by-hop, 
and that used end-to-end. End-to-end information in the transport layer
is associated with state at the endpoints, but processing of network-layer
information was assumed to be stateless.</t>

<t>The widespread deployment of stateful middleboxes in the Internet, such as
network address and port translators (NAPT), firewalls that model the TCP
state machine to distinguish packets belonging from desirable flows from
backscatter and random attack traffic, and devices which keep per-flow state
for reporting and monitoring purposes (e.g. IPFIX <xref target="RFC7011"/> Metering
Processes), has broken this assumption, and made it more difficult to deploy
non-TCP transport protocols in the Internet.</t>

<t>The deployment of new transport protocols encapsulated in UDP with encrypted
transport headers (such as QUIC <xref target="I-D.hamilton-quic-transport-protocol"/>) 
will present a challenge to the operation of these devices, and their ubquity
likewise threatens to impair the deployability of these protocols. There are
two main causes for this problem: first, stateful devices often use an
internal model of the TCP state machine to determine when TCP flows start and
end, allowing them to manage state for these flows; for UDP flows, they must
rely on timeouts. These timeouts are generally short relative to those for TCP
<xref target="IMC-GATEWAYS"/>, requiring UDP- encapsulated transports either to generate
unproductive keepalive traffic for long-lived sessions, or to tolerate
connectivity problems and the necessity of reconnection due to loss of on-path
state.</t>

<t>This document presents an abstract solution to this problem by defining a
transport-independent state machine to be implemented at per-flow state-
keeping middleboxes as a replacement for incomplete TCP state modeling. A key
concept behind this approach is that encryption of transport protocol headers
allows a transport protocol to separate its wire image – what it looks like
to devices on path – from its internal semantics. We advocate the creation of
a minimal wire image for these protocols that exposes enough information to
drive the state machine presented. Present and future evolution of encrypted
transport protocols can then happen behind this wire image, and  Middleboxes
implementing this state machine can use signals from a UDP encapsulation
common to a set of encrypted transport protocols can have equivalent state
information to that provided by TCP, reducing the friction between deployed
middleboxes and these new transport protocols.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In this document, the term “flow” is defined to be compatible with the
definition given in <xref target="RFC7011"/>: A flow is defined as a set of packets passing
a device on the network during a certain time interval. All packets belonging
to a particular Flow have a set of common properties. Each property is defined
as the result of applying a function to the values of:</t>

<t><list style="numbers">
  <t>one or more network layer header fields (e.g., destination IP
address) or transport layer header fields (e.g., destination port
number) that the device has access to;</t>
  <t>one or more characteristics of the packet itself (e.g., number
of MPLS labels, etc.);</t>
  <t>one or more of the fields derived from packet treatment at the device
(e.g., next-hop IP address, the output interface, etc.).</t>
</list></t>

<t>A packet is defined as belonging to a flow if it completely satisfies all the
defined properties of the flow.</t>

<t>A bidirectional flow or biflow is defined as compatible with <xref target="RFC5103"/>, by
joining the “forward direction” flow with the “reverse direction” flow,
derived by reversing the direction of directional fields (ports and IP
addresses). Biflows are only relevant at devices positioned so as to see all
the packets in both directions of the biflow, generally on the endpoint side
of the service demarcation point for either endpoint as defined in the
reference path given in <xref target="RFC7398"/>.</t>

</section>
<section anchor="state-machine" title="State Machine">

<t>A transport-independent state machine for on-path devices is shown in
<xref target="fig-states"/>. It was designed to have the following properties:</t>

<t><list style="symbols">
  <t>A device on path that can see traffic in both directions between two
endpoints knows that each side of an association wishes that association to
continue. This allows firewalls to delegate policy decisions about accepting
or continuing an association to the servers they protect.</t>
  <t>A device on path that can see traffic in both directions between two
endpoints knows that each device can receive traffic at the source address
it provides. This allows firewalls to provide protection against trivially
spoofed packets.</t>
</list></t>

<t>Both of these properties hold with current firewalls and network address
translation devices observing the flags and sequence/acknowledgment numbers
exposed by TCP.</t>

<t>It relies on five states, three configurable timeouts, and a
set of signals defined in <xref target="abstract-signaling-mechanisms"/>. The states are
defined as follows:</t>

<t><list style="symbols">
  <t>zero: there is no state for a given flow at the device</t>
  <t>uniflow: at least one packet has been seen in one direction</t>
  <t>associating: at least one packet has been seen in one direction, and an 
indication that the receiving endpoint wishes to continue the association has 
been seen in the other direction.</t>
  <t>associated: a flow in associating state has further demonstrated that the 
initial sender can receive packets at its given source address.</t>
  <t>closing: an association is shutting down due to an explicit close
signal.</t>
</list></t>

<t>We refer to the zero and uniflow states as “uniflow states”, as they are
relevant both for truly unidirectional flows, as well as in situations where
an on-path device can see only one side of a communication. We refer to the
remaining three states as “biflow states”, as they are only applicable to true
bidirectional flows, where the on-path device can see both sides of the
communication.</t>

<figure title="Transport-Independent State Machine for Stateful On-Path Devices" anchor="fig-states"><artwork><![CDATA[
      .- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -.
      '    +==============+    pkt(s->d)    +==========+              '
      '   //              \\-------------->/            \--+          '
      '  ((      zero      ))             (    uniflow   ) |pkt(s->d) '
      '   \\              //<--------------\            /<-+          '
      '    +==============+  TO_IDLE/close  +==========+              '
      '- - -|- - -  ^ - ^  - - - - - - - - - - - - - -|- - - - - - - -'
            |        \   \                            |  association
 TO_CLOSING |         \   \                           V  signal
      +==========+     \   \      TO_IDLE        +==========+  
     /            \     \   +-------------------/            \ 
    (    closing   )     \                     (  associating )
     \            /       \                     \            / 
      +==========+         \ TO_ASSOCIATED       +==========+  
            ^               \                         |
     close  |                \                        |  confirmation
    signal  |               +==========+              |  signal
            |              /            \             |
            |             (  associated  )            |
            +--------------\            /<------------+
                            +==========+  
                              |      ^
                              +------+
                             pkt(s<->d)
    
]]></artwork></figure>

<t>The three timeouts are defined as follows:</t>

<t><list style="symbols">
  <t>TO_IDLE, the unidirectional idle timeout, can be considered equivalent to
the idle timeout for transport protocols where the device has no information
about session start and end (e.g. most UDP protocols).</t>
  <t>TO_ASSOCIATED, the bidirectional idle timeout, can be considered equivalent
to the timeout for transport protocols where the device has information
about session start and end (e.g. TCP).</t>
  <t>TO_CLOSING is the closing timeout: how long the device will account
additional packets to a flow after observing a stop signal, ensuring a
reordered stop signal doesn’t create a new flow.</t>
</list></t>

<t>Selection of timeouts is a configuration and implementation detail, but
generally TO_CLOSING &lt;= TO_IDLE « TO_ASSOCIATED; see <xref target="IMC-GATEWAYS"/>.</t>

<section anchor="uniflow-states" title="Uniflow States">

<t>Every packet received by a device keeping per-flow state must associate that
packet with a flow (see <xref target="flow-identification"/>). When a device receives a
packet associated with a flow it has no state for, and it is configured to
forward the packet instead of dropping it, it moves that flow from the zero
state into the uniflow state and starts a timer TO_IDLE. It resets this timer
for any additional packet it forwards in the same direction as long as the
flow remains in the uniflow state. When timer TO_IDLE expires on a flow in the
uniflow state, the device drops state for the flow and performs any processing
associated with doing so: tearing down NAT bindings, closing associated
firewall pinholes, exporting flow information, and so on. The device may also
drop state on a stop signal, if observed.</t>

<t>Some devices will only see one side of a communication, e.g. if they are
placed in a portion of a network with asymmetric routing. These devices use
only the zero and uniflow states (as marked in <xref target="fig-states"/>.) In addition,
true uniflows – protocols which are solely unidirectional (e.g. some
applications over UDP) – will also use only the uniflow-only states. In
either case, current devices generally don’t associate much state with
observed uniflows, and an idle timeout is generally sufficient to expire this
state.</t>

</section>
<section anchor="biflow-states" title="Biflow States">

<t>A uniflow transitions to the associating state when the device observes an
association signal, and further to the associated state when the device
observes a subsequent confirmation signal; see 
<xref target="association-and-confirmation-signaling"/> for details. 
If the flow has not transitioned to from the
associating to the associated state after TO_IDLE, the device drops state for
the flow.</t>

<t>After transitioning to the associated state, the device starts a timer
TO_ASSOCIATED. It resets this timer for any packet it forwards in either
direction. The associated state represents a fully established bidirectional
communication. When timer TO_ASSOCIATED expires, the device assumes that the
flow has shut down without signaling as such, and drops state for the flow,
performing any associated processing. When a stop signal (see {{stop-
signaling}}) is observed in either direction, the flow transitions to the
closing state.</t>

<t>When a flow enters the closing state, it starts a timer TO_CLOSING. While the
stop signal should be the last packet on a flow, the TO_CLOSING timer ensures
that reordered packets after the stop signal will be accounted to the flow.
When this timer expires, the device drops state for the flow, performing any
associated processing.</t>

</section>
<section anchor="additional-states-and-actions" title="Additional States and Actions">

<t>This document is concerned only with states and transitions common to
transport- and function- independent state maintenance. Devices may augment
the transitions in this state diagram depending on their function. For
example, a firewall that decides based on some information beyond the signals
used by this state machine to shut down a flow may transition it directly to a
blacklist state on shutdown. Or, a firewall may fail to forward additional
packets in the uniflow state until an association signal is observed.</t>

</section>
</section>
<section anchor="abstract-signaling-mechanisms" title="Abstract Signaling Mechanisms">

<t>The state machine in <xref target="state-machine"/> requires four signals: a new flow
signal, the first packet observed in a flow in the zero state; an association
signal, allowing a device to verify that an endpoint wishes a bidirectional
communication to be established or to continue; a confirmation signal,
allowing a device to confirm that the initiator of a flow is reachable at its
purported source address; and a stop signal, noting that an endpoint wishes to
stop a bidirectional communication. Additional related signals may also be
useful, depending on the function a device provides. There are a few different
ways to implement these signals; here, we explore the properties of some
potential implementations.</t>

<t>We assume the following general requirements for these signals; parallel to
those given in <xref target="draft-trammell-plus-abstract-mech"/>:</t>

<t><list style="symbols">
  <t>At least the endpoints can verify the integrity of the signals exposed, and
shut down a transport association when that verification fails, in order to
reduce the incentive for on-path devices to attempt to spoof these signals.</t>
  <t>Endpoints and devices on path can probabilistically verify that a originator
of a signal is on-path.</t>
</list></t>

<section anchor="flow-identification" title="Flow Identification">

<t>In order to keep per-flow state, each device using this state machine must
have a function it can apply to each packet to be able to extract common
properties to identify the flow it is associated with. In general, the set of
properties used for flow identification on presently deployed devices includes
the source and destination IP address, the source and destination transport
layer port number, the transport protocol number. The differentiated services
field <xref target="RFC2474"/> may also be included in the set of properties defining a
flow, since it may indicate different forwarding treatment.</t>

<t>However, other protocols may use additional bits in their own headers for flow
identification. In any case, a protocol implementing signaling for this state
machine must specify the function used for flow identification.</t>

</section>
<section anchor="association-and-confirmation-signaling" title="Association and Confirmation Signaling">

<t>An association signal indicates that the endpoint that received the first
packet seen by the device is interested in continuing conversation with the
sending endpoint. This signal is roughly an in-band analogue to consent
signaling in ICE <xref target="RFC7675"/> that is carried to every device along the path.</t>

<t>A confirmation signal indicates that the endpoint that sent the first packet
seen by the device is reachable at its purported source address, and is
necessary to prevent spoofed or reflected packets from driving the state
machine into the associated state. It is roughly equivalent to the final ACK
in the TCP three-way handshake.</t>

<t>These two signals are related to each other, in that association requires the
receiving endpoint of the first packet to prove it has seen that packet (or a
subsequent packet), and to acknowledge it wants to continue the association;
while confirmation requires the sending endpoint to prove it has seen the
association token.</t>

<t>Transport-independent, path-verifiable association and confirmation signaling
can be implemented using three values carried in the packet headers: an
association token, a confirmation nonce, and an echo token.</t>

<t>The association token is a cryptographically random value generated by the
endpoint initiating a connection, and is carried on packets in the uniflow
state. When a receiving endpoint wishes to send an association signal, it
generates an echo token from the association token using a well-known, defined
function (e.g. a truncated SHA-256 hash), and generates a cryptographically
random confirmation nonce. The initiating endpoint sends a confirmation signal
on the next packet it sends after receiving the confirmation nonce, by
applying a function to the echo token and the confirmation nonce, and sending
the result as a new association token.</t>

<t>Devices on path verify that the echo token corresponds to a previously seen
association token to recognize an association signal, and recognize that an
association token corresponds to a previously seen echo token and confirmation
nonce to recognize an association signal.</t>

<t>These signals could be exposed on only first few packets of a connection
(those corresponding to the cryptographic and/or transport state handshakes in
the overlying protocols). In this case, an on-path device would need to
observe the start of the flow to establish state. They could also be present
on every packet in the flow, allowing state to be re-established even in the
middle of a flow with longer idle periods than the TO_ESTABLISHED timeout
value. In this case, the series of exposed association tokens, echo tokens,
and confirmation nonces can be observed to derive a running round-trip time
estimate for the flow.</t>

<t>If the association token and confirmation nonce are predictable, off-path
devices can spoof association and confirmation signals. In choosing the number
of bits for an association token, there is a tradeoff between per-packet
overhead and state overhead at on-path devices, and assurance that an
association token is hard to guess. This tradeoff must be evaluated at
protocol design time.</t>

<t>There are a few considerations in choosing a function (or functions) to
generate the echo token from the association token, to verify an echo token
given an association token, and to derive a next association token from the
echo token and confirmation nonce. The functions could be extremely simple
(e.g., identity for the echo token and addition for the nonce) for ease of
implementation even in extremely constrained environments. Using one-way
functions (e.g., truncated SHA-256 hash to derive echo token from association
token; XOR followed by truncated SHA-256 hash to derive association token from
echo token and confirmation nonce) requires slightly more work from on-path
devices, but the primitives will be available at any endpoint using an
encrypted transport protocol. In any case, a concrete implementation of
association and confirmation signaling must choose a set of functions, or
mechanism for unambiguously choosing one, at both endpoints as well as along
the path.</t>

</section>
<section anchor="stop-signaling" title="Stop Signaling">

<t>A stop signal is directly carried or otherwise encoded in the protocol
header to indicate that a flow is ending, whether normally or abnormally, and
that state associated with the flow should be torn down. Upon decoding a stop
signal, a device on path should move the flow from uniflow state to null, or
from biflow state to closing.</t>

<t>Transports should send a stop signal only on the last packet sent in a
bidirectional flow. The closing timeout TO_CLOSING is intended to ensure that
any packets reordered in delivery are accounted to the flow before state for
it is dropped.</t>

<t>We assume the encoding of a stop signal into a packet header, as with all
other signals, is integrity protected end-to-end. Stop signals, as association
signals, could be forged by one on-path device to dupe other devices into
moving flows into the closing state. However, state will be re-established by
the continuing flow (and resulting association signals) after the closing
timeout, and an endpoint receiving a spoofed stop signal could enter a fast
re-establishment phase of the upper layer transport protocol to minimize
disruption, further reducing the incentive to attackers to spoof stop signals.</t>

<t>Alternatively, the stop signal could be designed to authenticate itself. Each
endpoint could reveal a stop hash during the initial association, which is the
result of a chosen cryptographic hash function applied to a stop token which
that endpoint keeps secret. An endpoint wishing to end the association then
reveals the stop token, which can be verified both by the far endpoint and
devices on path which have cached the stop hash to be authentic.</t>

</section>
</section>
<section anchor="deployment-considerations" title="Deployment Considerations">

<t>The state machine defined in this document is most useful when implemented in
a single instantiation (wire format for signals, and selection of functions
for deriving values to be exposed and verified) by multiple transport
protocols. It is intended for use with protocols that encrypt their transport-
layer headers, and that are encapsulated within UDP, as is the case with QUIC
<xref target="I-D.hamilton-quic-transport-protocol"/>. Definition of that instantiation is
out of scope for the present revision of this document.</t>

<t>The following subsections discuss incentives for deployment of this state
machine both at middleboxes and at endpoints.</t>

<section anchor="middlebox-deployment" title="Middlebox Deployment">

<t>The state machine defined herein is designed to replace TCP state-tracking for
firewalls and NAT devices. When encrypted transport protocols encapsulated in
UDP adopt a set of signals and a wire format for those signals to drive this
state machine, these middleboxes could continue using TCP-like logic to handle
those UDP flows. Recognizing the wire format used by those signals would allow
these middleboxes to distinguish “UDP with an encrypted transport” from
undifferentiated UDP, and to treat the former case more like TCP, providing
longer timeouts for established flows, as well as stateful defense against
spoofed or reflected garbage traffic.</t>

</section>
<section anchor="endpoint-deployment" title="Endpoint Deployment">

<t>An encrypted, UDP-encapsulated transport protocol has two primary incentives
to expose these signals. First, allowing firewalls on networks that generally
block UDP (about 3-5% of Internet-connected networks, depending on the study)
to distinguish “UDP with an encrypted transport” traffic from other UDP
traffic may result in less blocking of that traffic. Second, the difference
between the timeouts TO_IDLE and TO_ASSOCIATED, as well as the continuous
state establishment possible with some instantiations of the association and
confirmation signals, would allow these transport protocols to send less
unproductive keepalive traffic for long-lived, sparse flows.</t>

<t>While both of these advantages require middleboxes on path to recognize and
use the signals driving this state machine, we note that content providers
driving the deployment of this protocols are also operators of their own
content provision networks, and that many of the benefits of encrypted-
encapsulated transport firewalls will accrue to them, giving these content providers incentives to deploy both endpoints and middleboxes.</t>

</section>
</section>
<section anchor="signal-mappings-for-transport-protocols" title="Signal mappings for transport protocols">

<t>We now show how this state machine can be driven by signals available in TCP and QUIC.</t>

<section anchor="signal-mapping-for-tcp" title="Signal mapping for TCP">

<t>A mapping of TCP flags to transitions in to the state machine in<vspace />
<xref target="state-machine"/> shows how devices currently using a model of the 
TCP state machine can be converted to use this state machine.</t>

<t>TCP <xref target="RFC0793"/> provides start-of-flow association only. A packet with the SYN
and ACK flags set in the absence of the FIN or RST flags, and an in-window
acknowledgment number, is synonymous with the association signal. A packet
with the ACK flag set in the absence of the FIN or RST flags after an initial
SYN, and an in-window acknowledgment number, is synonymous with the
confirmation signal. For a typical TCP flow:</t>

<t><list style="numbers">
  <t>The initial SYN places the flow into uniflow state,</t>
  <t>The SYN-ACK sent in reply acts as a association signal and places the flow into associating state,</t>
  <t>The ACK sent in reply acts as a confirmatio signal and places the flow into associated state,</t>
  <t>Any RST moves the flow into closing state, or</t>
  <t>The final FIN-ACK (not the first half-close FIN) moves the flow into closing state.</t>
</list></t>

<t>Note that generating a stop signal from FIN does require
additional TCP state modeling to prevent moving into the closing state on a
half-close.</t>

<t>Note also that the association and stop signals derived from the TCP header
are not integrity protected, and association and confirmation signals based on
in-window ACK are not particularly resistant to off-path attacks <xref target="IMC-TCP"/>.
The state machine is therefore more susceptible to manipulation when used with
vanilla TCP as when with a transport protocol providing full integrity
protection for its headers end-to-end.</t>

</section>
<section anchor="signal-mapping-for-quic" title="Signal mapping for QUIC">

<t>QUIC <xref target="I-D.hamilton-quic-transport-protocol"/> is a moving target; however,
signals for driving this state machine are fundamentally compatible with the
protocol’s design and could easily be added to the protocol specification.</t>

<t>Specifically, as of this writing, QUIC’s 64-bit connection ID, together with
integrity protection of the connection ID provided by QUIC’s cryptographic
protocol <xref target="I-D.thomson-quic-tls"/>, could be used as an association and echo
token as in <xref target="association-and-confirmation-signaling"/>. A confirmation nonce,
or equivalent mechanism, is presently missing and would have to be added. The
addition of a public reset signal that would act as a stop signal as in
<xref target="stop-signaling"/> is presently under discussion on the QUIC mailing list; one
proposal for self-authenticating public reset inspired the addition of a
comparable mechanism to <xref target="stop-signaling"/> of this document.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no actions for IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This document defines a state machine for transport-independent state
management on middleboxes, using in-band signaling, to replace the commonly-
implemented current practice of incomplete TCP state modeling on these
devices. It defines new signals for state management. While these signals can
be spoofed by any device on path that observes traffic in both directions, we
presume the presence of end-to-end integrity protection of these signals
provided by the upper-layer transport driving them. This allows such spoofing
to be detected and countered by endpoints, reducing the threat from on-path
devices to connection disruption, which such devices are trivially placed to
perform in any case.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>Thanks to Christian Huitema for discussions leading to this document, and to
Andrew Yourtchenko for the feedback. The mechanism for using a revealed value
to prove ownership of a stop token was inspired by Eric Rescorla’s suggestion
to use a fundamentally identical mechanism for the QUIC public reset.</t>

<t>This work is partially supported by the European Commission under Horizon 2020
grant agreement no. 688421 Measurement and Architecture for a Middleboxed
Internet (MAMI), and by the Swiss State Secretariat for Education, Research,
and Innovation under contract no. 15.0268. This support does not imply
endorsement.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC5103' target='http://www.rfc-editor.org/info/rfc5103'>
<front>
<title>Bidirectional Flow Export Using IP Flow Information Export (IPFIX)</title>
<author initials='B.' surname='Trammell' fullname='B. Trammell'><organization /></author>
<author initials='E.' surname='Boschi' fullname='E. Boschi'><organization /></author>
<date year='2008' month='January' />
<abstract><t>This document describes an efficient method for exporting bidirectional flow (Biflow) information using the IP Flow Information Export (IPFIX) protocol, representing each Biflow using a single Flow Record.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5103'/>
<seriesInfo name='DOI' value='10.17487/RFC5103'/>
</reference>



<reference  anchor='RFC7011' target='http://www.rfc-editor.org/info/rfc7011'>
<front>
<title>Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information</title>
<author initials='B.' surname='Claise' fullname='B. Claise' role='editor'><organization /></author>
<author initials='B.' surname='Trammell' fullname='B. Trammell' role='editor'><organization /></author>
<author initials='P.' surname='Aitken' fullname='P. Aitken'><organization /></author>
<date year='2013' month='September' />
<abstract><t>This document specifies the IP Flow Information Export (IPFIX) protocol, which serves as a means for transmitting Traffic Flow information over the network.  In order to transmit Traffic Flow information from an Exporting Process to a Collecting Process, a common representation of flow data and a standard means of communicating them are required.  This document describes how the IPFIX Data and Template Records are carried over a number of transport protocols from an IPFIX Exporting Process to an IPFIX Collecting Process.  This document obsoletes RFC 5101.</t></abstract>
</front>
<seriesInfo name='STD' value='77'/>
<seriesInfo name='RFC' value='7011'/>
<seriesInfo name='DOI' value='10.17487/RFC7011'/>
</reference>



<reference  anchor='RFC7398' target='http://www.rfc-editor.org/info/rfc7398'>
<front>
<title>A Reference Path and Measurement Points for Large-Scale Measurement of Broadband Performance</title>
<author initials='M.' surname='Bagnulo' fullname='M. Bagnulo'><organization /></author>
<author initials='T.' surname='Burbridge' fullname='T. Burbridge'><organization /></author>
<author initials='S.' surname='Crawford' fullname='S. Crawford'><organization /></author>
<author initials='P.' surname='Eardley' fullname='P. Eardley'><organization /></author>
<author initials='A.' surname='Morton' fullname='A. Morton'><organization /></author>
<date year='2015' month='February' />
<abstract><t>This document defines a reference path for Large-scale Measurement of Broadband Access Performance (LMAP) and measurement points for commonly used performance metrics.  Other similar measurement projects may also be able to use the extensions described here for measurement point location.  The purpose is to create an efficient way to describe the location of the measurement point(s) used to conduct a particular measurement.</t></abstract>
</front>
<seriesInfo name='RFC' value='7398'/>
<seriesInfo name='DOI' value='10.17487/RFC7398'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC0793' target='http://www.rfc-editor.org/info/rfc793'>
<front>
<title>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1981' month='September' />
</front>
<seriesInfo name='STD' value='7'/>
<seriesInfo name='RFC' value='793'/>
<seriesInfo name='DOI' value='10.17487/RFC0793'/>
</reference>



<reference  anchor='RFC2474' target='http://www.rfc-editor.org/info/rfc2474'>
<front>
<title>Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</title>
<author initials='K.' surname='Nichols' fullname='K. Nichols'><organization /></author>
<author initials='S.' surname='Blake' fullname='S. Blake'><organization /></author>
<author initials='F.' surname='Baker' fullname='F. Baker'><organization /></author>
<author initials='D.' surname='Black' fullname='D. Black'><organization /></author>
<date year='1998' month='December' />
<abstract><t>This document defines the IP header field, called the DS (for differentiated services) field.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='2474'/>
<seriesInfo name='DOI' value='10.17487/RFC2474'/>
</reference>



<reference  anchor='RFC7675' target='http://www.rfc-editor.org/info/rfc7675'>
<front>
<title>Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness</title>
<author initials='M.' surname='Perumal' fullname='M. Perumal'><organization /></author>
<author initials='D.' surname='Wing' fullname='D. Wing'><organization /></author>
<author initials='R.' surname='Ravindranath' fullname='R. Ravindranath'><organization /></author>
<author initials='T.' surname='Reddy' fullname='T. Reddy'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson'><organization /></author>
<date year='2015' month='October' />
<abstract><t>To prevent WebRTC applications, such as browsers, from launching attacks by sending traffic to unwilling victims, periodic consent to send needs to be obtained from remote endpoints.</t><t>This document describes a consent mechanism using a new Session Traversal Utilities for NAT (STUN) usage.</t></abstract>
</front>
<seriesInfo name='RFC' value='7675'/>
<seriesInfo name='DOI' value='10.17487/RFC7675'/>
</reference>



<reference anchor='I-D.hamilton-quic-transport-protocol'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>

<author initials='R' surname='Hamilton' fullname='Ryan Hamilton'>
    <organization />
</author>

<author initials='J' surname='Iyengar' fullname='Janardhan Iyengar'>
    <organization />
</author>

<author initials='I' surname='Swett' fullname='Ian Swett'>
    <organization />
</author>

<author initials='A' surname='Wilk' fullname='Alyssa Wilk'>
    <organization />
</author>

<date month='October' day='31' year='2016' />

<abstract><t>QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience, and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the basis of QUIC is intended to address compatibility issues with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing third parties from from changing them.  QUIC encrypts most of its headers, thereby limiting protocol evolution to QUIC endpoints only.  Therefore, middleboxes, in large part, are not required to be updated as new protocol versions are deployed.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC's loss recovery and congestion control, and the use of TLS 1.3 for key negotiation.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-hamilton-quic-transport-protocol-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hamilton-quic-transport-protocol-01.txt' />
</reference>



<reference anchor='I-D.thomson-quic-tls'>
<front>
<title>Using Transport Layer Security (TLS) to Secure QUIC</title>

<author initials='M' surname='Thomson' fullname='Martin Thomson'>
    <organization />
</author>

<author initials='R' surname='Hamilton' fullname='Ryan Hamilton'>
    <organization />
</author>

<date month='October' day='25' year='2016' />

<abstract><t>This document describes how Transport Layer Security (TLS) can be used to secure QUIC.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-thomson-quic-tls-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-thomson-quic-tls-01.txt' />
</reference>



<reference anchor='I-D.hardie-path-signals'>
<front>
<title>Path signals</title>

<author initials='T' surname='Hardie' fullname='Ted Hardie'>
    <organization />
</author>

<date month='October' day='28' year='2016' />

<abstract><t>TCP's state mechanics uses a series of well-known messages that are exchanged in the clear.  Because these are visible to network elements on the path between the two nodes setting up the transport connection, they are often used as signals by those network elements. In transports that do not exchange these messages in the clear, on- path network elements lack those signals.  This document discusses the nature of the signals as they are seen by on-path elements and reflects on best practices for transports which encrypt their state mechanics.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-hardie-path-signals-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-hardie-path-signals-00.txt' />
</reference>


<reference anchor="draft-trammell-plus-abstract-mech" >
  <front>
    <title>Abstract Mechanisms for a Cooperative Path Layer under Endpoint Control</title>
    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization>ETH Zurich</organization>
    </author>
    <date year="2016" month="September" day="28"/>
  </front>
</reference>
<reference anchor="IMC-GATEWAYS" >
  <front>
    <title>An experimental study of home gateway characteristics (Proc. ACM IMC 2010)</title>
    <author initials="S." surname="Hatonen">
      <organization></organization>
    </author>
    <author initials="A." surname="Nyrhinen">
      <organization></organization>
    </author>
    <author initials="L." surname="Eggert">
      <organization></organization>
    </author>
    <author initials="S." surname="Strowes">
      <organization></organization>
    </author>
    <author initials="P." surname="Sarolahti">
      <organization></organization>
    </author>
    <author initials="M." surname="Kojo">
      <organization></organization>
    </author>
    <date year="2010" month="October"/>
  </front>
</reference>
<reference anchor="IMC-TCP" >
  <front>
    <title>Resilience of Deployed TCP to Blind Attacks. (Proc. ACM IMC 2015)</title>
    <author initials="M." surname="Luckie">
      <organization></organization>
    </author>
    <author initials="R." surname="Beverly">
      <organization></organization>
    </author>
    <author initials="T." surname="Wu">
      <organization></organization>
    </author>
    <author initials="M." surname="Allman">
      <organization></organization>
    </author>
    <author initials="k." surname="claffy">
      <organization></organization>
    </author>
    <date year="2015" month="October"/>
  </front>
</reference>


    </references>



  </back>
</rfc>

