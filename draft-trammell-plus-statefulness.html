<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Transport-Independent Path Layer State Management</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 State Machine"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Uniflow States"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Biflow States"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Additional States and Actions"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Abstract Signaling Mechanisms"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Flow Identification"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Association and Confirmation Signaling"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Stop Signaling"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Separate Utility"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Deployment Considerations"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Middlebox Deployment"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Endpoint Deployment"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Signal mappings for transport protocols"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Signal mapping for TCP"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Signal mapping for QUIC"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="10 References"/>
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Kuehlewind, M., Trammell, B., and J. Hildebrand" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-plus-statefulness-02" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-12-01" />
  <meta name="dct.abstract" content="This document describes a simple state machine for stateful network devices on a path between two endpoints to associate state with traffic traversing them on a per-flow basis, as well as abstract signaling mechanisms for driving the state machine. This state machine is intended to replace the de-facto use of the TCP state machine or incomplete forms thereof by stateful network devices in a transport-independent way, while still allowing for fast state timeout of non-established or undesirable flows." />
  <meta name="description" content="This document describes a simple state machine for stateful network devices on a path between two endpoints to associate state with traffic traversing them on a per-flow basis, as well as abstract signaling mechanisms for driving the state machine. This state machine is intended to replace the de-facto use of the TCP state machine or incomplete forms thereof by stateful network devices in a transport-independent way, while still allowing for fast state timeout of non-established or undesirable flows." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">M. Kuehlewind</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">B. Trammell</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">ETH Zurich</td>
</tr>
<tr>
  <td class="left">Expires: June 4, 2017</td>
  <td class="right">J. Hildebrand</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">December 01, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Transport-Independent Path Layer State Management<br />
  <span class="filename">draft-trammell-plus-statefulness-02</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes a simple state machine for stateful network devices on a path between two endpoints to associate state with traffic traversing them on a per-flow basis, as well as abstract signaling mechanisms for driving the state machine. This state machine is intended to replace the de-facto use of the TCP state machine or incomplete forms thereof by stateful network devices in a transport-independent way, while still allowing for fast state timeout of non-established or undesirable flows.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 4, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Terminology</a></li>
<li>3.   <a href="#rfc.section.3">State Machine</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Uniflow States</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Biflow States</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Additional States and Actions</a></li>
</ul><li>4.   <a href="#rfc.section.4">Abstract Signaling Mechanisms</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Flow Identification</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Association and Confirmation Signaling</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Stop Signaling</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Separate Utility</a></li>
</ul><li>5.   <a href="#rfc.section.5">Deployment Considerations</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Middlebox Deployment</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Endpoint Deployment</a></li>
</ul><li>6.   <a href="#rfc.section.6">Signal mappings for transport protocols</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Signal mapping for TCP</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Signal mapping for QUIC</a></li>
</ul><li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<li>8.   <a href="#rfc.section.8">Security Considerations</a></li>
<li>9.   <a href="#rfc.section.9">Acknowledgments</a></li>
<li>10.   <a href="#rfc.references">References</a></li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">The boundary between the network and transport layers was originally defined to be that between information used (and potentially modified) hop-by-hop, and that used end-to-end. End-to-end information in the transport layer is associated with state at the endpoints, but processing of network-layer information was assumed to be stateless.</p>
<p id="rfc.section.1.p.2">The widespread deployment of stateful middleboxes in the Internet, such as network address and port translators (NAPT), firewalls that model the TCP state machine to distinguish packets belonging from desirable flows from backscatter and random attack traffic, and devices which keep per-flow state for reporting and monitoring purposes (e.g. IPFIX <a href="#RFC7011">[RFC7011]</a> Metering Processes), has broken this assumption, and made it more difficult to deploy non-TCP transport protocols in the Internet.</p>
<p id="rfc.section.1.p.3">The deployment of new transport protocols encapsulated in UDP with encrypted transport headers (such as QUIC <a href="#I-D.hamilton-quic-transport-protocol">[I-D.hamilton-quic-transport-protocol]</a>) will present a challenge to the operation of these devices, and their ubquity likewise threatens to impair the deployability of these protocols. There are two main causes for this problem: first, stateful devices often use an internal model of the TCP state machine to determine when TCP flows start and end, allowing them to manage state for these flows; for UDP flows, they must rely on timeouts. These timeouts are generally short relative to those for TCP <a href="#IMC-GATEWAYS">[IMC-GATEWAYS]</a>, requiring UDP- encapsulated transports either to generate unproductive keepalive traffic for long-lived sessions, or to tolerate connectivity problems and the necessity of reconnection due to loss of on-path state.</p>
<p id="rfc.section.1.p.4">This document presents an abstract solution to this problem by defining a transport-independent state machine to be implemented at per-flow state- keeping middleboxes as a replacement for incomplete TCP state modeling. A key concept behind this approach is that encryption of transport protocol headers allows a transport protocol to separate its wire image &#8211; what it looks like to devices on path &#8211; from its internal semantics. We advocate the creation of a minimal wire image for these protocols that exposes enough information to drive the state machine presented. Present and future evolution of encrypted transport protocols can then happen behind this wire image, and  Middleboxes implementing this state machine can use signals from a UDP encapsulation common to a set of encrypted transport protocols can have equivalent state information to that provided by TCP, reducing the friction between deployed middleboxes and these new transport protocols.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.2.p.1">In this document, the term &#8220;flow&#8221; is defined to be compatible with the definition given in <a href="#RFC7011">[RFC7011]</a>: A flow is defined as a set of packets passing a device on the network during a certain time interval. All packets belonging to a particular Flow have a set of common properties. Each property is defined as the result of applying a function to the values of:</p>
<p/>

<ol>
  <li>one or more network layer header fields (e.g., destination IP address) or transport layer header fields (e.g., destination port number) that the device has access to;</li>
  <li>one or more characteristics of the packet itself (e.g., number of MPLS labels, etc.);</li>
  <li>one or more of the fields derived from packet treatment at the device (e.g., next-hop IP address, the output interface, etc.).</li>
</ol>
<p id="rfc.section.2.p.3">A packet is defined as belonging to a flow if it completely satisfies all the defined properties of the flow.</p>
<p id="rfc.section.2.p.4">A bidirectional flow or biflow is defined as compatible with <a href="#RFC5103">[RFC5103]</a>, by joining the &#8220;forward direction&#8221; flow with the &#8220;reverse direction&#8221; flow, derived by reversing the direction of directional fields (ports and IP addresses). Biflows are only relevant at devices positioned so as to see all the packets in both directions of the biflow, generally on the endpoint side of the service demarcation point for either endpoint as defined in the reference path given in <a href="#RFC7398">[RFC7398]</a>.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#state-machine" id="state-machine">State Machine</a></h1>
<p id="rfc.section.3.p.1">A transport-independent state machine for on-path devices is shown in <a href="#fig-states">Figure 1</a>. It was designed to have the following properties:</p>
<p/>

<ul>
  <li>A device on path that can see traffic in both directions between two endpoints knows that each side of an association wishes that association to continue. This allows firewalls to delegate policy decisions about accepting or continuing an association to the servers they protect.</li>
  <li>A device on path that can see traffic in both directions between two endpoints knows that each device can receive traffic at the source address it provides. This allows firewalls to provide protection against trivially spoofed packets.</li>
</ul>
<p id="rfc.section.3.p.3">Both of these properties hold with current firewalls and network address translation devices observing the flags and sequence/acknowledgment numbers exposed by TCP.</p>
<p id="rfc.section.3.p.4">It relies on five states, three configurable timeouts, and a set of signals defined in <a href="#abstract-signaling-mechanisms">Section 4</a>. The states are defined as follows:</p>
<p/>

<ul>
  <li>zero: there is no state for a given flow at the device</li>
  <li>uniflow: at least one packet has been seen in one direction</li>
  <li>associating: at least one packet has been seen in one direction, and an indication that the receiving endpoint wishes to continue the association has been seen in the other direction.</li>
  <li>associated: a flow in associating state has further demonstrated that the initial sender can receive packets at its given source address.</li>
  <li>closing: an association is shutting down due to an explicit close signal.</li>
</ul>
<p id="rfc.section.3.p.6">We refer to the zero and uniflow states as &#8220;uniflow states&#8221;, as they are relevant both for truly unidirectional flows, as well as in situations where an on-path device can see only one side of a communication. We refer to the remaining three states as &#8220;biflow states&#8221;, as they are only applicable to true bidirectional flows, where the on-path device can see both sides of the communication.</p>
<div id="rfc.figure.1"/>
<div id="fig-states"/>
<pre>
      .- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -.
      '    +==============+    pkt(s-&gt;d)    +==========+              '
      '   //              \\--------------&gt;/            \--+          '
      '  ((      zero      ))             (    uniflow   ) |pkt(s-&gt;d) '
      '   \\              //&lt;--------------\            /&lt;-+          '
      '    +==============+  TO_IDLE/close  +==========+              '
      '- - -|- - -  ^ - ^  - - - - - - - - - - - - - -|- - - - - - - -'
            |        \   \                            |  association
 TO_CLOSING |         \   \                           V  signal
      +==========+     \   \      TO_IDLE        +==========+  
     /            \     \   +-------------------/            \--+ 
    (    closing   )     \                     (  associating ) | pkt
     \            /       \                     \            /&lt;-+(s-&gt;d)
      +==========+         \ TO_ASSOCIATED       +==========+  
            ^               \                         |
            |               +==========+              |  
     close  |              /            \             |  confirmation
    signal  |             (  associated  )            |  signal
            +--------------\            /&lt;------------+
                            +==========+  
                              |      ^
                              +------+
                             pkt(s&lt;-&gt;d)
    
</pre>
<p class="figure">Figure 1: Transport-Independent State Machine for Stateful On-Path Devices</p>
<p id="rfc.section.3.p.7">The three timeouts are defined as follows:</p>
<p/>

<ul>
  <li>TO_IDLE, the unidirectional idle timeout, can be considered equivalent to the idle timeout for transport protocols where the device has no information about session start and end (e.g. most UDP protocols).</li>
  <li>TO_ASSOCIATED, the bidirectional idle timeout, can be considered equivalent to the timeout for transport protocols where the device has information about session start and end (e.g. TCP).</li>
  <li>TO_CLOSING is the closing timeout: how long the device will account additional packets to a flow after observing a stop signal, ensuring a reordered stop signal doesn&#8217;t create a new flow.</li>
</ul>
<p id="rfc.section.3.p.9">Selection of timeouts is a configuration and implementation detail, but generally TO_CLOSING &lt;= TO_IDLE &#171;&#160;TO_ASSOCIATED; see <a href="#IMC-GATEWAYS">[IMC-GATEWAYS]</a>.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#uniflow-states" id="uniflow-states">Uniflow States</a></h1>
<p id="rfc.section.3.1.p.1">Every packet received by a device keeping per-flow state must associate that packet with a flow (see <a href="#flow-identification">Section 4.1</a>). When a device receives a packet associated with a flow it has no state for, and it is configured to forward the packet instead of dropping it, it moves that flow from the zero state into the uniflow state and starts a timer TO_IDLE. It resets this timer for any additional packet it forwards in the same direction as long as the flow remains in the uniflow state. When timer TO_IDLE expires on a flow in the uniflow state, the device drops state for the flow and performs any processing associated with doing so: tearing down NAT bindings, closing associated firewall pinholes, exporting flow information, and so on. The device may also drop state on a stop signal, if observed.</p>
<p id="rfc.section.3.1.p.2">Some devices will only see one side of a communication, e.g. if they are placed in a portion of a network with asymmetric routing. These devices use only the zero and uniflow states (as marked in <a href="#fig-states">Figure 1</a>.) In addition, true uniflows &#8211; protocols which are solely unidirectional (e.g. some applications over UDP) &#8211; will also use only the uniflow-only states. In either case, current devices generally don&#8217;t associate much state with observed uniflows, and an idle timeout is generally sufficient to expire this state.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#biflow-states" id="biflow-states">Biflow States</a></h1>
<p id="rfc.section.3.2.p.1">A uniflow transitions to the associating state when the device observes an association signal, and further to the associated state when the device observes a subsequent confirmation signal; see <a href="#association-and-confirmation-signaling">Section 4.2</a> for details.  If the flow has not transitioned to from the associating to the associated state after TO_IDLE, the device drops state for the flow.</p>
<p id="rfc.section.3.2.p.2">After transitioning to the associated state, the device starts a timer TO_ASSOCIATED. It resets this timer for any packet it forwards in either direction. The associated state represents a fully established bidirectional communication. When timer TO_ASSOCIATED expires, the device assumes that the flow has shut down without signaling as such, and drops state for the flow, performing any associated processing. When a stop signal (see {{stop- signaling}}) is observed in either direction, the flow transitions to the closing state.</p>
<p id="rfc.section.3.2.p.3">When a flow enters the closing state, it starts a timer TO_CLOSING. While the stop signal should be the last packet on a flow, the TO_CLOSING timer ensures that reordered packets after the stop signal will be accounted to the flow.  When this timer expires, the device drops state for the flow, performing any associated processing.</p>
<p id="rfc.section.3.2.p.4">Spurious closing signals can be cancelled</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#additional-states-and-actions" id="additional-states-and-actions">Additional States and Actions</a></h1>
<p id="rfc.section.3.3.p.1">This document is concerned only with states and transitions common to transport- and function- independent state maintenance. Devices may augment the transitions in this state diagram depending on their function. For example, a firewall that decides based on some information beyond the signals used by this state machine to shut down a flow may transition it directly to a blacklist state on shutdown. Or, a firewall may fail to forward additional packets in the uniflow state until an association signal is observed.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#abstract-signaling-mechanisms" id="abstract-signaling-mechanisms">Abstract Signaling Mechanisms</a></h1>
<p id="rfc.section.4.p.1">The state machine in <a href="#state-machine">Section 3</a> requires four signals: a new flow signal, the first packet observed in a flow in the zero state; an association signal, allowing a device to verify that an endpoint wishes a bidirectional communication to be established or to continue; a confirmation signal, allowing a device to confirm that the initiator of a flow is reachable at its purported source address; and a stop signal, noting that an endpoint wishes to stop a bidirectional communication. Additional related signals may also be useful, depending on the function a device provides. There are a few different ways to implement these signals; here, we explore the properties of some potential implementations.</p>
<p id="rfc.section.4.p.2">We assume the following general requirements for these signals; parallel to those given in <a href="#draft-trammell-plus-abstract-mech">[draft-trammell-plus-abstract-mech]</a>:</p>
<p/>

<ul>
  <li>At least the endpoints can verify the integrity of the signals exposed, and shut down a transport association when that verification fails, in order to reduce the incentive for on-path devices to attempt to spoof these signals.</li>
  <li>Endpoints and devices on path can probabilistically verify that a originator of a signal is on-path.</li>
</ul>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#flow-identification" id="flow-identification">Flow Identification</a></h1>
<p id="rfc.section.4.1.p.1">In order to keep per-flow state, each device using this state machine must have a function it can apply to each packet to be able to extract common properties to identify the flow it is associated with. In general, the set of properties used for flow identification on presently deployed devices includes the source and destination IP address, the source and destination transport layer port number, the transport protocol number. The differentiated services field <a href="#RFC2474">[RFC2474]</a> may also be included in the set of properties defining a flow, since it may indicate different forwarding treatment.</p>
<p id="rfc.section.4.1.p.2">However, other protocols may use additional bits in their own headers for flow identification. In any case, a protocol implementing signaling for this state machine must specify the function used for flow identification.</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#association-and-confirmation-signaling" id="association-and-confirmation-signaling">Association and Confirmation Signaling</a></h1>
<p id="rfc.section.4.2.p.1">An association signal indicates that the endpoint that received the first packet seen by the device has indeed seen that packet, and is interested in continuing conversation with the sending endpoint. This signal is roughly an in-band analogue to consent signaling in ICE <a href="#RFC7675">[RFC7675]</a> that is carried to every device along the path.</p>
<p id="rfc.section.4.2.p.2">A confirmation signal indicates that the endpoint that sent the first packet seen by the device is reachable at its purported source address, and is necessary to prevent spoofed or reflected packets from driving the state machine into the associated state. It is roughly equivalent to the final ACK in the TCP three-way handshake.</p>
<p id="rfc.section.4.2.p.3">These two signals are related to each other, in that association requires the receiving endpoint of the first packet to prove it has seen that packet (or a subsequent packet), and to acknowledge it wants to continue the association; while confirmation requires the sending endpoint to prove it has seen the association token.</p>
<p id="rfc.section.4.2.p.4">Transport-independent, path-verifiable association and confirmation signaling can be implemented using three values carried in the packet headers: an association token, a confirmation nonce, and an echo token.</p>
<p id="rfc.section.4.2.p.5">The association token is a cryptographically random value generated by the endpoint initiating a connection, and is carried on packets in the uniflow state. When a receiving endpoint wishes to send an association signal, it generates an echo token from the association token using a well-known, defined function (e.g. a truncated SHA-256 hash), and generates a cryptographically random confirmation nonce. The initiating endpoint sends a confirmation signal on the next packet it sends after receiving the confirmation nonce, by applying a function to the echo token and the confirmation nonce, and sending the result as a new association token.</p>
<p id="rfc.section.4.2.p.6">Devices on path verify that the echo token corresponds to a previously seen association token to recognize an association signal, and recognize that an association token corresponds to a previously seen echo token and confirmation nonce to recognize an association signal.</p>
<p id="rfc.section.4.2.p.7">These signals could be exposed on only first few packets of a connection (those corresponding to the cryptographic and/or transport state handshakes in the overlying protocols). In this case, an on-path device would need to observe the start of the flow to establish state. They could also be present on every packet in the flow, allowing state to be re-established even in the middle of a flow with longer idle periods than the TO_ESTABLISHED timeout value. In this case, the series of exposed association tokens, echo tokens, and confirmation nonces can be observed to derive a running round-trip time estimate for the flow.</p>
<p id="rfc.section.4.2.p.8">If the association token and confirmation nonce are predictable, off-path devices can spoof association and confirmation signals. In choosing the number of bits for an association token, there is a tradeoff between per-packet overhead and state overhead at on-path devices, and assurance that an association token is hard to guess. This tradeoff must be evaluated at protocol design time.</p>
<p id="rfc.section.4.2.p.9">There are a few considerations in choosing a function (or functions) to generate the echo token from the association token, to verify an echo token given an association token, and to derive a next association token from the echo token and confirmation nonce. The functions could be extremely simple (e.g., identity for the echo token and addition for the nonce) for ease of implementation even in extremely constrained environments. Using one-way functions (e.g., truncated SHA-256 hash to derive echo token from association token; XOR followed by truncated SHA-256 hash to derive association token from echo token and confirmation nonce) requires slightly more work from on-path devices, but the primitives will be available at any endpoint using an encrypted transport protocol. In any case, a concrete implementation of association and confirmation signaling must choose a set of functions, or mechanism for unambiguously choosing one, at both endpoints as well as along the path.</p>
<p id="rfc.section.4.2.p.10">Note that sending a packet without a stop signal on the reverse</p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#stop-signaling" id="stop-signaling">Stop Signaling</a></h1>
<p id="rfc.section.4.3.p.1">A stop signal is directly carried or otherwise encoded in the protocol header to indicate that a flow is ending, whether normally or abnormally, and that state associated with the flow should be torn down. Upon decoding a stop signal, a device on path should move the flow from uniflow state to null, or from biflow state to closing.</p>
<p id="rfc.section.4.3.p.2">Transports should send a stop signal only on the last packet sent in a bidirectional flow. The closing timeout TO_CLOSING is intended to ensure that any packets reordered in delivery are accounted to the flow before state for it is dropped.</p>
<p id="rfc.section.4.3.p.3">We assume the encoding of a stop signal into a packet header, as with all other signals, is integrity protected end-to-end. Stop signals, as association signals, could be forged by one on-path device to dupe other devices into moving flows into the closing state. However, state will be re-established by the continuing flow (and resulting association signals) after the closing timeout, and an endpoint receiving a spoofed stop signal could enter a fast re-establishment phase of the upper layer transport protocol to minimize disruption, further reducing the incentive to attackers to spoof stop signals.</p>
<p id="rfc.section.4.3.p.4">Alternatively, the stop signal could be designed to authenticate itself. Each endpoint could reveal a stop hash during the initial association, which is the result of a chosen cryptographic hash function applied to a stop token which that endpoint keeps secret. An endpoint wishing to end the association then reveals the stop token, which can be verified both by the far endpoint and devices on path which have cached the stop hash to be authentic.</p>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#separate-utility" id="separate-utility">Separate Utility</a></h1>
<p id="rfc.section.4.4.p.1">Although all of these signals are required to drive the state machine described by this document, note that association/confirmation and stop signaling have separate utility. A transport protocol may expose the end of a flow without any proof of association or confirmation of return routability of the initiator. Alternately, the transport protocol could rely on short timeouts to clean up stale state on path, while exposing continuous association and confirmation signals to quickly reestablish state.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#deployment-considerations" id="deployment-considerations">Deployment Considerations</a></h1>
<p id="rfc.section.5.p.1">[EDITOR&#8217;S NOTE: discuss incentives for deployment for signals separately here]</p>
<p id="rfc.section.5.p.2">The state machine defined in this document is most useful when implemented in a single instantiation (wire format for signals, and selection of functions for deriving values to be exposed and verified) by multiple transport protocols. It is intended for use with protocols that encrypt their transport- layer headers, and that are encapsulated within UDP, as is the case with QUIC <a href="#I-D.hamilton-quic-transport-protocol">[I-D.hamilton-quic-transport-protocol]</a>. Definition of that instantiation is out of scope for the present revision of this document.</p>
<p id="rfc.section.5.p.3">The following subsections discuss incentives for deployment of this state machine both at middleboxes and at endpoints.</p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#middlebox-deployment" id="middlebox-deployment">Middlebox Deployment</a></h1>
<p id="rfc.section.5.1.p.1">The state machine defined herein is designed to replace TCP state-tracking for firewalls and NAT devices. When encrypted transport protocols encapsulated in UDP adopt a set of signals and a wire format for those signals to drive this state machine, these middleboxes could continue using TCP-like logic to handle those UDP flows. Recognizing the wire format used by those signals would allow these middleboxes to distinguish &#8220;UDP with an encrypted transport&#8221; from undifferentiated UDP, and to treat the former case more like TCP, providing longer timeouts for established flows, as well as stateful defense against spoofed or reflected garbage traffic.</p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#endpoint-deployment" id="endpoint-deployment">Endpoint Deployment</a></h1>
<p id="rfc.section.5.2.p.1">An encrypted, UDP-encapsulated transport protocol has two primary incentives to expose these signals. First, allowing firewalls on networks that generally block UDP (about 3-5% of Internet-connected networks, depending on the study) to distinguish &#8220;UDP with an encrypted transport&#8221; traffic from other UDP traffic may result in less blocking of that traffic. Second, the difference between the timeouts TO_IDLE and TO_ASSOCIATED, as well as the continuous state establishment possible with some instantiations of the association and confirmation signals, would allow these transport protocols to send less unproductive keepalive traffic for long-lived, sparse flows.</p>
<p id="rfc.section.5.2.p.2">While both of these advantages require middleboxes on path to recognize and use the signals driving this state machine, we note that content providers driving the deployment of this protocols are also operators of their own content provision networks, and that many of the benefits of encrypted- encapsulated transport firewalls will accrue to them, giving these content providers incentives to deploy both endpoints and middleboxes.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#signal-mappings-for-transport-protocols" id="signal-mappings-for-transport-protocols">Signal mappings for transport protocols</a></h1>
<p id="rfc.section.6.p.1">We now show how this state machine can be driven by signals available in TCP and QUIC.</p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#signal-mapping-for-tcp" id="signal-mapping-for-tcp">Signal mapping for TCP</a></h1>
<p id="rfc.section.6.1.p.1">A mapping of TCP flags to transitions in to the state machine in<br/> <a href="#state-machine">Section 3</a> shows how devices currently using a model of the TCP state machine can be converted to use this state machine.</p>
<p id="rfc.section.6.1.p.2">TCP <a href="#RFC0793">[RFC0793]</a> provides start-of-flow association only. A packet with the SYN and ACK flags set in the absence of the FIN or RST flags, and an in-window acknowledgment number, is synonymous with the association signal. A packet with the ACK flag set in the absence of the FIN or RST flags after an initial SYN, and an in-window acknowledgment number, is synonymous with the confirmation signal. For a typical TCP flow:</p>
<p/>

<ol>
  <li>The initial SYN places the flow into uniflow state,</li>
  <li>The SYN-ACK sent in reply acts as a association signal and places the flow into associating state,</li>
  <li>The ACK sent in reply acts as a confirmatio signal and places the flow into associated state,</li>
  <li>Any RST moves the flow into closing state, or</li>
  <li>The final FIN-ACK (not the first half-close FIN) moves the flow into closing state.</li>
</ol>
<p id="rfc.section.6.1.p.4">Note that generating a stop signal from FIN does require additional TCP state modeling to prevent moving into the closing state on a half-close.</p>
<p id="rfc.section.6.1.p.5">Note also that the association and stop signals derived from the TCP header are not integrity protected, and association and confirmation signals based on in-window ACK are not particularly resistant to off-path attacks <a href="#IMC-TCP">[IMC-TCP]</a>.  The state machine is therefore more susceptible to manipulation when used with vanilla TCP as when with a transport protocol providing full integrity protection for its headers end-to-end.</p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#signal-mapping-for-quic" id="signal-mapping-for-quic">Signal mapping for QUIC</a></h1>
<p id="rfc.section.6.2.p.1">QUIC <a href="#I-D.hamilton-quic-transport-protocol">[I-D.hamilton-quic-transport-protocol]</a> is a moving target; however, signals for driving this state machine are fundamentally compatible with the protocol&#8217;s design and could easily be added to the protocol specification.</p>
<p id="rfc.section.6.2.p.2">Specifically, as of this writing, QUIC&#8217;s 64-bit connection ID, together with integrity protection of the connection ID provided by QUIC&#8217;s cryptographic protocol <a href="#I-D.thomson-quic-tls">[I-D.thomson-quic-tls]</a>, could be used as an association and echo token as in <a href="#association-and-confirmation-signaling">Section 4.2</a>. A confirmation nonce, or equivalent mechanism, is presently missing and would have to be added. The addition of a public reset signal that would act as a stop signal as in <a href="#stop-signaling">Section 4.3</a> is presently under discussion on the QUIC mailing list; one proposal for self-authenticating public reset inspired the addition of a comparable mechanism to <a href="#stop-signaling">Section 4.3</a> of this document.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.7.p.1">This document has no actions for IANA.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.8.p.1">This document defines a state machine for transport-independent state management on middleboxes, using in-band signaling, to replace the commonly- implemented current practice of incomplete TCP state modeling on these devices. It defines new signals for state management. While these signals can be spoofed by any device on path that observes traffic in both directions, we presume the presence of end-to-end integrity protection of these signals provided by the upper-layer transport driving them. This allows such spoofing to be detected and countered by endpoints, reducing the threat from on-path devices to connection disruption, which such devices are trivially placed to perform in any case.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.9.p.1">Thanks to Christian Huitema for discussions leading to this document, and to Andrew Yourtchenko for the feedback. The mechanism for using a revealed value to prove ownership of a stop token was inspired by Eric Rescorla&#8217;s suggestion to use a fundamentally identical mechanism for the QUIC public reset.</p>
<p id="rfc.section.9.p.2">This work is partially supported by the European Commission under Horizon 2020 grant agreement no. 688421 Measurement and Architecture for a Middleboxed Internet (MAMI), and by the Swiss State Secretariat for Education, Research, and Innovation under contract no. 15.0268. This support does not imply endorsement.</p>
<h1 id="rfc.references"><a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC5103">[RFC5103]</b>
      </td>
      <td class="top"><a>Trammell, B.</a> and <a>E. Boschi</a>, "<a href="http://tools.ietf.org/html/rfc5103">Bidirectional Flow Export Using IP Flow Information Export (IPFIX)</a>", RFC 5103, DOI 10.17487/RFC5103, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7011">[RFC7011]</b>
      </td>
      <td class="top"><a>Claise, B.</a>, <a>Trammell, B.</a> and <a>P. Aitken</a>, "<a href="http://tools.ietf.org/html/rfc7011">Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information</a>", STD 77, RFC 7011, DOI 10.17487/RFC7011, September 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7398">[RFC7398]</b>
      </td>
      <td class="top"><a>Bagnulo, M.</a>, <a>Burbridge, T.</a>, <a>Crawford, S.</a>, <a>Eardley, P.</a> and <a>A. Morton</a>, "<a href="http://tools.ietf.org/html/rfc7398">A Reference Path and Measurement Points for Large-Scale Measurement of Broadband Performance</a>", RFC 7398, DOI 10.17487/RFC7398, February 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="draft-trammell-plus-abstract-mech">[draft-trammell-plus-abstract-mech]</b>
      </td>
      <td class="top"><a title="ETH Zurich">Trammell, B.</a>, "<a>Abstract Mechanisms for a Cooperative Path Layer under Endpoint Control</a>", September 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.hamilton-quic-transport-protocol">[I-D.hamilton-quic-transport-protocol]</b>
      </td>
      <td class="top"><a>Hamilton, R.</a>, <a>Iyengar, J.</a>, <a>Swett, I.</a> and <a>A. Wilk</a>, "<a href="http://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-01">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-hamilton-quic-transport-protocol-01, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.hardie-path-signals">[I-D.hardie-path-signals]</b>
      </td>
      <td class="top"><a>Hardie, T.</a>, "<a href="http://tools.ietf.org/html/draft-hardie-path-signals-00">Path signals</a>", Internet-Draft draft-hardie-path-signals-00, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.thomson-quic-tls">[I-D.thomson-quic-tls]</b>
      </td>
      <td class="top"><a>Thomson, M.</a> and <a>R. Hamilton</a>, "<a href="http://tools.ietf.org/html/draft-thomson-quic-tls-01">Using Transport Layer Security (TLS) to Secure QUIC</a>", Internet-Draft draft-thomson-quic-tls-01, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="IMC-GATEWAYS">[IMC-GATEWAYS]</b>
      </td>
      <td class="top"><a>Hatonen, S.</a>, <a>Nyrhinen, A.</a>, <a>Eggert, L.</a>, <a>Strowes, S.</a>, <a>Sarolahti, P.</a> and <a>M. Kojo</a>, "<a>An experimental study of home gateway characteristics (Proc. ACM IMC 2010)</a>", October 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="IMC-TCP">[IMC-TCP]</b>
      </td>
      <td class="top"><a>Luckie, M.</a>, <a>Beverly, R.</a>, <a>Wu, T.</a>, <a>Allman, M.</a> and <a>k. claffy</a>, "<a>Resilience of Deployed TCP to Blind Attacks. (Proc. ACM IMC 2015)</a>", October 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC0793">[RFC0793]</b>
      </td>
      <td class="top"><a>Postel, J.</a>, "<a href="http://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2474">[RFC2474]</b>
      </td>
      <td class="top"><a>Nichols, K.</a>, <a>Blake, S.</a>, <a>Baker, F.</a> and <a>D. Black</a>, "<a href="http://tools.ietf.org/html/rfc2474">Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</a>", RFC 2474, DOI 10.17487/RFC2474, December 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7675">[RFC7675]</b>
      </td>
      <td class="top"><a>Perumal, M.</a>, <a>Wing, D.</a>, <a>Ravindranath, R.</a>, <a>Reddy, T.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7675">Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness</a>", RFC 7675, DOI 10.17487/RFC7675, October 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> 
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Joe Hildebrand</span> 
	  <span class="n hidden">
		<span class="family-name">Hildebrand</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:hildjj@cursive.net">hildjj@cursive.net</a></span>

  </address>
</div>

</body>
</html>
